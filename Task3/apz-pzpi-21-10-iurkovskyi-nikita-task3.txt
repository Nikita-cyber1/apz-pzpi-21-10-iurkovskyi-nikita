Міністерство освіти та науки України
Харківський національний університет радіоелектроніки



Кафедра «Програмної інженерії» 



Звіт
до лабораторної роботи № 3
з курсу «Архітектура програмного забезпечення»




Виконав:                                                                                                   Перевірив: 
Ст. групи ПЗПІ-21-10                                              Доцент каф. ПІ Сокорчук І.П. 
Юрковський Н.Ю.











Харків 2024
Мета роботи
     
     Розробити програмне забезпечення для SmartDevice пристрою на базі такої платформи, як Adruino, яка є придатною для реалізації вбудованих систем. Реалізувати розширену функціональність, що відповідає концепції  SmartDevice, та забезпечити взаємодію із іншими частинами системи, такими як серверна частина та мобільний застосунок.
     
Хід роботи
     
     1. Ознайомлення з платформою Arduino, вивчення плати з власним процесором та пам’яттю Arduino Nano.
     2. Підключення до макетної плати RGB-світлодіоду.
     3. Написання скетчу, що дозволяє на основі отриманих від комп’ютера даних формувати чергу та моделювати процес приготування їжі, а інформацію про статус замовлення надсилати до сервера.
     4. Забезпечення взаємодії мобільного застосунку з розумним пристроєм через послідовний порт.
     5. Визначення кольорів для індикації приготування різних інгредієнтів.
     6. Побудова UML діаграм: діаграми прецедентів (Use Case Diagram), діаграми взаємодії (Interaction Overview Diagram), діаграми діяльності (Activity Diagram) та діаграми станів (State Diagram).


     Для наочного відображення й розуміння дій користувача в ході використання програми було спроектовано UseCase UML діаграму 
(див. рис. 1). 
     

Рисунок 1 – Діаграма прецедентів розроблюваної системи

     Із неї чітко видно, що акторами, які безпосередньо взаємодіють із системою, є адміністратор, який має необмежений доступ до усього функціоналу системи (у тому числі до управління даними користувачів та усіх таблиць БД, що дозволяють змоделювати предметну область, експортування та імпортування даних, резервне копіювання, захист даних від стороннього доступу шляхом управління сертифікатами), авторизований користувач, який має ті самі права, окрім адміністрування системи, та неавторизований користувач. 
	Із неї чітко видно, що акторами, які безпосередньо взаємодіють із системою, є адміністратор, який здійснює управління системою і відповідає за її працездатність, користувачі, що мають платну підписку чи безкоштовний акаунт і взаємодіють із системою для замовлення і отримання їжі, а також працівники закладів громадського харчування.
	Адміністратор має необмежений доступ до функціоналу керування системою. У його обов’язки входить створення резервних копій бази даних, її відновлення у разі припинення нормального функціонування програмного продукту, здійснення керування сертифікатами, що включає у себе відслідковування строку дії SSL-сертифікату та його оновлення у разі потреби. Та основною роботою, що здійснює даний актор, є керування даними системи. Він керує даними таблиць бази даних, а саме: додає нові дані до таблиць, редагує наявні таблиці, може видаляти зайві сутності, а також переглядати усі дані, пов’язані із таблицею і її вмістом.
	Користувач із безкоштовним акаунтом може використовувати основний функціонал, що дозволить йому отримати приготовану страву. Він може У закладі харчування у мобільному додатку відсканувати NFC-мітку, після чого отримає доступ до каталогу страв, що пропонує даний заклад харчування. Після цього є можливість переглянути усі страви, що його цікавлять, у чому може допомогти можливість фільтрації, сортування каталогу, а також функція пошуку у ньому, ознайомитися із інформацією про страви, визначити її наповнення та додати до кошику, відредагувати вміст кошику та зробити замовлення, яке буде приготовано і можна буде отримати відповідно до черги. Даний користувач має право здійснити пошук закладів харчування, що можуть приготувати вибрані ним страви і знаходяться у тій місцевості, яку він вкаже, а також знайти страви, котрі складаються із вибраних користувачем інгредієнтів, при цьому даному актору можна вибрати, скільки із вказаних інгредієнтів може бути відсутніми у складі рецепту страви.
	Користувач, що має платну підписку, може здійснити замовлення страви онлайн на вибраний ним час, а також має привілеї при розрахування черги: він може переміститися одразу в середину черги, яка складається лише з користувачів із безкоштовною підпискою.
	Взаємодію із системою також здійснює працівник закладу харчування. Коли у апараті для приготування страви не вистачає певних інгредієнтів, від повідомляє про це і даний актор повинен поповнити запаси інгредієнтів для підтримки обслуговування системою користувачів.
     Усі можливі дії, які можуть виконувати користувачі, але з детальною інформацією про обмін повідомленнями всередині системи, показано на діаграмі взаємодії (див. додаток А). Згідно із нею, користувач може здійснювати реєстрацію та авторизацію в системі, що призведе до зміни його статусу і надасть доступ до того функціоналу програми, що недоступний для неавторизованих користувачів. Адміністратор здійснює управляння даними, сертифікатами та резервними копіями бази даних. Клієнт може переглядати каталог, додавати обрані страви до кошику, на основі вмісту якого потім оформити замовлення. Замовлення надсилаються користувачем до програмної системи, а вона, у свою чергу, обирає автомат для приготування вказаної у замовленні їжі та надсилає відповідні дані для здійснення замовлення до вибраної машини.  Вона визначає місце у черзі та час приготування та надає ці дані серверу, який за запитом користувача може їх відобразити. 
     Детальний алгоритм роботи відображено на діаграмі діяльності (див. додаток Б). Відповідно до неї, користувач перевіряє, чи надійшли нові замовлення, зчитуючи дані із COM-порту. Якщо нових даних не надійшло, здійснюється перевірка, чи наявні у черзі замовлення, що мають бути приготовані. У противному разі отримані дані розглядаються як такі, що знаходяться у форматі JSON, доступ до окремих елементів даних відбувається аналогічним чином, як і виконується звернення до об’єктів та масивів JavaScript. Отримуються усі нові замовлення, інформація про склад кожної страви замовлень, після чого визначається, яке місце у черзі отримає поточне замовлення. Існує наступне правило: замовлення користувача, що має платну підписку, може потрапити у позицію, що знаходиться до середини черги, при цьому не можна випереджати інших користувачів із платною підпискою, а користувачів, що користуються системою безкоштовно, можна випереджати максимум 3 рази. Після цього перевіряється, яка страва має готуватися наступною, і якщо у черзі наявні замовлення, то перше із них вилучається із черги та готується. Після приготування автомат очікує 5 секунд та знову перевіряє наявність нових замовлень. Скетч наведено у додатку Г.
     Для опису поведінки окремо узятого об'єкта системи, насамперед реактивного (поведінка якого характеризується його реакцією на зовнішні події) було розроблено діаграму станів (див. додаток В). Детально показано такі стани користувача, як неавторизований та активний, процес переходу від одного стану до іншого. Чітко видно, в яких станах перебуває об’єкт в рамках експлуатації системи, які кроки потрібно пройти, аби перейти з одного стану в інший.
     Серверна частина програмної системи отримує дані через COM-порт, аналізуючи потік байтів, що ним надсилається, та перетворюючи їх у рядки символів. Слід зазначити, що плата Arduino Nano з’єднується із сервером за допомогою USB-mini.
     Архітектура програмного продукту є двошаровою (шар бізнес-логіки, де відбувається контроль за чергою, та шар представлення, у якому відбувається моделювання процесу приготування їжі) та однорівневою, адже розміщується у межах одного фізичного пристрою.







     
     
     
     
     
     
     
     
     
     
     
ВИСНОВКИ

     В ході виконання даної лабораторної роботи було створено SmartDevice пристрій, на базі популярної сьогодні платформи для розробки вбудованих систем Arduino Nano. Було отримано навички роботи з самою платою завдяки вивченню її структури, PIN-ів, засобів з’єднання із макетною платою. На практиці освоєно роботу із сітлодіодами, способами їх з’єднання із Arduino. Закріплено навички створення скетчів, їх завантаження та роботу з COM-портами. Забезпечено взаємодію розумного пристрою із серверною частиною системи.
     Відеоролик з демонстрацією роботи Iot пристрою:
      https://youtu.be/Kp9SoHCLat4
     Відеоролик з поясненням роботи програмного коду:
      https://youtu.be/5ZaBQu-n5Vc
     Посилання на GitHub репозиторій з джерельним кодом:
     https://github.com/NureIurkovskyiNikita/apz-pzpi-21-10-iurkovskyi-nikita/tree/main/Task3
     Додаток А
Діаграма взаємодії



Рисунок 2 - Діаграма взаємодії розумного пристрою










Додаток Б
Діаграма діяльності


Рисунок 3 - Діаграма діяльності програмної системи


Додаток В
Діаграма станів


Рисунок 4 - Діаграма станів програмної системи

Додаток Г
Клас черги замовлень


class Queue {
public:
    void add_new_order(Order* order) {
        if (last_order == nullptr) {
            first_order = last_order = order;
            order->set_next_order(nullptr);
            order->set_previous_order(nullptr);
            order->set_index_number(1);
        } else {
            if (!order->is_user_vip()) {
                order->set_next_order(last_order);
                order->set_previous_order(nullptr);
                last_order = order;
            } else {
                int order_index = size;
                Order* current_order = last_order;

                while (order_index >= size / 2) {
                    if (current_order->is_user_vip() 
                        || current_order->get_shift_count() 
                        == MAX_SHIFT_COUNT) {
                        break;
                    } else {
                        current_order->increment_shift_count();
                        current_order = current_order->get_next_order();
                    }
                    ++order_index;
                }

                int last_index = current_order->get_index_number();
                if (current_order == last_order) {
                    current_order->set_previous_order(order);
                    order->set_next_order(current_order);
                    order->set_previous_order(nullptr);
                    last_order = order;
                } else {
                    current_order->set_previous_order(order);
                    current_order->get_previous_order()->set_next_order(order);
                    order->set_next_order(current_order);
                    order->set_previous_order(
                        current_order->get_previous_order()
                    );
                }
                update_indexes(order, last_index);
            }
        }
        ++size;
    }

    Order* start_dish_cooking() {
        Order* order_to_cook = first_order;
        if (!size) {
            first_order = last_order = nullptr;
        } else {
            Order* new_first_order = first_order->get_previous_order();
            new_first_order->set_next_order(nullptr);

            if (size == 1) {
                new_first_order->set_previous_order(nullptr);
                first_order = last_order = new_first_order;
            }
        }

        return order_to_cook;
    }

    void update_indexes(Order* start_order, int index) {
        Order* current_order = start_order;
        int current_index = index;
        while (current_order) {
            current_order->set_index_number(current_index++);
            current_order = current_order->get_previous_order();
        }
    }

    Order* get_first_order() {
        return first_order;
    }

    int get_size() const {
        return size;
    }

private:
    Order* first_order;
    Order* last_order;
    int size;
};

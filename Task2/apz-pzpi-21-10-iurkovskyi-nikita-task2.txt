
Міністерство освіти та науки України 
 
Харківський національний університет радіоелектроніки 

 
 
 
Кафедра «Програмної інженерії»  
 
 
 

Звіт з лабораторної роботи № 2
з курсу «Архітектура програмного забезпечення»

Тема проекту: «Програмна система для автоматизації кулінарії на харчових підприємствах»
 
 
 
 
 
 
 
Виконав:                                                                                                   Перевірив:             
 
ст. гр. ПЗПІ-21-10                                   ст. викладач. кафедри ПІ Сокорчук І.П. 
 
Юрковський Н.Ю. 
 
 
 
 
 
 
 
 
 
 
Харків 2024
 
РОЗРОБКА СЕРВЕРНОЇ / BACK-END ЧАСТИНИ

1 Мета 
 
 
     Написати програмний код для реалізації серверної / backend частини програмної системи для попереднього замовлення їжі та напоїв: реалізувати бізнес-логіку, створити базу даних, яка зберігатиме усю необхідну для програмної системи інформацію, надати API для забезпечення можливості взаємодії з програмним продуктом за допомогою HTTP-запитів, 
 
 
2 Хід роботи 
 
 
2.1 Побудова UML діаграми розгортання  
 
 
     Мета створення UML діаграми розгортання полягає в моделюванні фізичної архітектури системи та розташування її компонентів у середовищі виконання. Також ця діаграма допомагає визначити взаємозв'язки між компонентами системи. Ви можете переглянути UML діаграму розгортання для розроблюваної системи на рисунку 1. 
     
     

 
 
Рисунок 1 – UML діаграма розгортання 
  
     З неї видно, що система складається із рівня серверу бази даних (використовується СУБД PostgreSQL), який пов’язаний із backend-сервером, що містить основну бізнес-логіку системи із використанням веб-фреймворку Django, за допомогою протоколу TCP/IP. Клієнт як із веб-додатку, так і з мобільного застосунку використовує протокол HTTP для виконання запитів і отримання відповідей від backend-сервера. При цьому цей же протокол використовується для виконання запитів із браузера користувача до frontendсервера. Для отримання інформації про нові замовлення розумний пристрій так само використовує протокол HTTP. 
 
Для опису поведінки окремо узятого об'єкта системи, насамперед 
реактивного (поведінка якого характеризується його реакцією на зовнішні події), було розроблено діаграму станів (див. дод. Б). Детально показано такі стани користувача, як неавторизований та активний, процес переходу від одного стану до іншого. Чітко видно, в яких станах перебуває об’єкт в рамках експлуатації системи, які кроки потрібно пройти, аби перейти з одного стану в інший. 



2.2 Побудова UML діаграми прецедентів  
 
 
     Для наочного відображення й розуміння дій користувача в ході використання програми було спроектовано UseCase UML діаграму (див. рис. 2).
 


 
Рисунок 2 – Діаграма прецедентів розроблюваної системи 
 
 
     Із неї чітко видно, що акторами, які безпосередньо взаємодіють із системою, є адміністратор, який здійснює управління системою і відповідає за її працездатність, користувачі, що мають платну підписку чи безкоштовний акаунт і взаємодіють із системою для замовлення і отримання їжі, а також працівники закладів громадського харчування. 
     Адміністратор має необмежений доступ до функціоналу керування системою. У його обов’язки входить створення резервних копій бази даних, її відновлення у разі припинення нормального функціонування програмного продукту, здійснення керування сертифікатами, що включає у себе відслідковування строку дії SSL-сертифікату та його оновлення у разі потреби. Та основною роботою, що здійснює даний актор, є керування даними системи. Він керує даними таблиць бази даних, а саме: додає нові дані до таблиць, редагує наявні таблиці, може видаляти зайві сутності, а також переглядати усі дані, пов’язані із таблицею і її вмістом. 
 
     Користувач із безкоштовним акаунтом може використовувати основний функціонал, що дозволить йому отримати приготовану страву. Він може У закладі харчування у мобільному додатку відсканувати NFC-мітку, після чого отримає доступ до каталогу страв, що пропонує даний заклад харчування. Після цього є можливість переглянути усі страви, що його цікавлять, у чому може допомогти можливість фільтрації, сортування каталогу, а також функція пошуку 
 
у ньому, ознайомитися із інформацією про страви, визначити її наповнення та додати до кошику, відредагувати вміст кошику та зробити замовлення, яке буде приготовано і можна буде отримати відповідно до черги. Даний користувач має право здійснити пошук закладів харчування, що можуть приготувати вибрані ним страви і знаходяться у тій місцевості, яку він вкаже, а також знайти страви, 
 
котрі складаються із вибраних користувачем інгредієнтів, при цьому даному актору можна вибрати, скільки із вказаних інгредієнтів може бути відсутніми у складі рецепту страви. 
 
     Користувач, що маж платну підписку, може здійснити замовлення страви онлайн на вибраний ним час, а також має привілеї при розрахування черги: він може переміститися одразу в середину черги, яка складається лише з користувачів із безкоштовною підпискою. 
 
     Взаємодію із системою також здійснює працівник закладу харчування. Коли у апараті для приготування страви не вистачає певних інгредієнтів, від повідомляє про це і даний актор повинен поповнити запаси інгредієнтів для підтримки обслуговування системою користувачів. 
 
 
2.3 Побудова ER – діаграми  
 
 
     Розроблена база даних дозволяє зберігати усю необхідну для забезпечення виконання усіх вище перерахованих дій. В якості СУБД було використано PostgreSQL, налаштування моделей даних відбувалося завдяки Django ORM. 
Фреймворк Django дозволяє зручно побудувати моделі даних шляхом створення класів і перерахування полів, які міститимуться у відповідних таблицях із вказанням типів даних, які представлятимуть вміст полів. 
 
     Створивши концептуальну модель предметної області, було спроектовано базу даних і побудовано ER-діаграму (див. рис. 3). 
 

 
Рисунок 3 – ER – модель даних  
 
З наведеної вище діаграми видно, що БД має наступні сутності: 
 
     - заклад громадського харчування (дозволяє ідентифікувати заклад, де користувач може замовити їжу, містить також інформацію про 
розташування); 
 
     - тип автомату (ідентифікує тип автомату, від якого залежить, які страви можуть бути приготовані); 
 
     - автомат закладу харчування (містить інформацію про те, у якому закладі знаходиться даний тип автомату); 
 
     - страва (інформація про страву, що може бути приготована у закладах харчування, які підключені до системи); 
     - страва, яку готує тип автомату (вказує, які страви можуть бути приготовані певним типом автомату відповідно до їх конструкції); 
 
     - інгредієнт (складові, з яких автомат готує страви); 

     - інгредієнт  у  страві  (визначає,  які  саме  інгредієнти  містяться  у 
 
стравах); 
 
     - замовлений користувачем інгредієнт страви (так як користувач може коригувати вміст страви, змінюючи кількісні показники інгредієнтів чи визначаючи їх наявність, то дана таблиця зберігає для кожної замовленої користувачем страви вміст інгредієнтів); 
 
     - користувач (авторизована особа, що може виконувати передбачені системою дії від свого імені); 
 
     - відгук про страву (містить коментарі користувача, що він може залишити після вживання страви, аби поділитися своїми враженнями). 
 
     Між сутностями бази даних існують зв’язки, що забезпечують їх взаємодію. Реалізуються зв’язки Б:Б шляхом створення проміжних таблиць, зв’язок із якими є 1:Б: 
 
     - заклад громадського харчування – тип автомату (один заклад громадського харчування може містити декілька автоматів, а один тип автоматів може знаходитися у різних закладах); 
 
     - тип автомату – страва (один тип автомату може готувати різні страви, 
 
одну страву може готувати декілька автоматів); 
 
     - страва – інгредієнт (одна страва складається з багатьох інгредієнтів, 
 
один інгредієнт входить до складу декількох страв); 
 
     - страва – користувач (одна страва може мати відгуки від різних користувачів, один користувач може залишити відгуки про різні страви); 
 
     - інгредієнт у страві – користувач (один інгредієнт може входити до складу замовлення багатьох користувачів, один користувач замовляє страви з багатьох інгредієнтів). 
 
 
 
2.5 Побудова UML діаграми станів  
 
 
     Архітектура програмної системи побудована за класичним підходом Django – використовується модель Model-View-Controller. Дані у системі мають вигляд об’єктів, тобто створюються класи, поля яких і будуть рядками таблиці бази даних. Завдяки вбудованої у фреймворк ORM відбувається перетворення сказаних класів у таблиці, а пов’язані між собою поля класів – у зв’язки між таблицями. 
     Для надання API, за допомогою яких інші частини системи зможуть взаємодіяти із серверною частиною застосунку, використовується Django REST framework. Вигляди визначають, які функції будуть доступні через інтерфейс користувача. В межах вигляду визначається набір даних, з якими він працюватиме та серіалізатор, що надасть визначені дані у зручній формі. У рамках даного проекту дані моделей перетворюються у формат JSON для 
передачі клієнту, адже даний формат є надзвичайно популярним і підтримується більшістю мов програмування, що полегшує розробку клієнтських застосунків для нього. Маршрутизатор задає URL-адреси, що надають доступ до кожного вигляду. Маршрутизатори являють собою верхній рівень API. 
 
     Для автентифікації в системі було використано JWT-токени. До них відносять access-токени (токени доступу), які генеруються у разі введення валідних даних користувачем, зберігаються на пристрої-клієнті та передаються з кожним запитом у заголовку, та refresh-токени, які дозволяють згенерувати новий access-токен, коли час дії старого сплив. Перевага такого способу автентифікації полягає у тому, що токени не потрібно зберігати на сервері та вони мають високу надійність, оскільки передбачають наявність цифрового підпису. Можна обрати, який використовувати алгоритм шифрування для генерації JWT-токенів та час дії токена доступу. В рамках розробленої системи використовується алгоритм HS256 та час дії – 60 хвилин. 
 
     Для забезпечення цілісності даних і для відновлення системи у випадку аварійної ситуації було реалізовано виконання функцій створення резервних копій та відновлення бази даних зі створених копій. Реалізація цього функціоналу відбувається із використанням бібліотеки django-dbbackup. Створено API, при отриманні POST-запитів до яких викликаються відповідні функції для створення копії чи відновлення, які виконуються в рамках операційної системи, а після завершення операції користувач отримує HTTPвідповідь про її успішність. 
     Забезпечено захист даних: було встановлено SSL-сертифікат, що дозволяє встановлювати лише безпечне з’єднання із клієнтом. Для керування сертифікатами було створено API, при запиті до якого відбувається оновлення існуючого сертифікату. Програмно реалізовані сповіщення про те, що строк дії сертифікату спливає, аби адміністратор розумів, коли його потрібно оновити. 
 
     Основною бізнес-логікою серверної частини системи є реалізація «розумного» підбору: виконується підбір страв, що можуть бути приготовані із вказаних інгредієнтів (див. дод. А), та підбір закладів, у яких можуть бути приготовані вказані страви (див. дод. Б). 
 
     В рамках реалізації підбору страв користувачем у параметрах GET-запиту надсилаються інгредієнти, що мають бути складовими страв, а також кількість інгредієнтів, що можуть бути відсутніми у одній страві. У межах алгоритму отримується список id усіх страв, потім для кожної страви визначається множина 
 
її інгредієнтів, знаходиться її різниця із множиною інгредієнтів, переданих користувачем і на основі кількості інгредієнтів, що не входять у отриману множину відсутніх у страві інгредієнтів робиться висновок, чи задовольняє ця страва умовам пошуку. В результаті виконання даного алгоритму отримуються 
 
2 списки – страви, що містять усі інгредієнти, та ті, у яких не вистачає декількох але не більше, ніж вказав користувач. 
 
     Для пошуку закладів громадського харчування, у яких можуть бути приготовані вибрані користувачем страви, користувачем задаються відповідні страви а також бажане місцерозташування закладу: країна, місто, вулиця. Алгоритм відбирає усі типи автоматів, що можуть приготувати дану страву, отримує автомати для кожного із закладів, визначає, які давні автомати в сукупності можуть приготувати страви у межах закладу, і якщо множина заданих користувачем страв є підмножиною страв, що можуть бути приготованими у закладі, робиться висновок, що даний заклад відповідає умовам пошуку. 
 

 
Рисунок 4 – UML діаграма станів 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
2.5 Опис інженерних рішень. Специфікація API REST  
 
 
     Передача даних між частинами системи відбувається через протокол HTTP, а самі дані серіалізовані у формат JSON, що є зручним як для упакування даних, так і розпакування клієнтом. Для взаємодії із даними через реалізовні API використовуються такі методи HTTP-запитів, як GET (отримання), POST (надсилання), PUT та PATCH (повне та часткове оновлення відповідно), DELETE (видалення). 
     Документація для API формується завдяки фреймворку Swagger, проте також є можливість переглянути альтернативний варіант Redis. У табл. 1 наведено, яким чином можна здійснити виконання запитів до серверної частини для кожної із сутностей. 
 
Таблиця 1 – Специфікація REST 
 
Роль,  що 
Ендпоінт 
HTTP- 
Призначення 	 
має доступ 
 
 
 
 
метод 
 
 
 	 	 
 	 	 
 	 
Registered 
/catering_establishment/ 
GET 
Повертає 	список
User, 
 
 
закладів 	умежах
Admin 
 
 
 
 
 
системи 	 	 
 	 	 
Registered 
/catering_establishment/{id}/ 
GET 
Повертає 	заклад 	із
User, 
Admin 
 
 
 
 
 
 
 
вказаним id  	 
 	 	 
 	 
Admin 
 
 
/catering_establishment/ 
 
 
POST 
 
 
Додавання нового закладу до системи  
 	 
Admin 
 
 
/catering_establishment/{id}/ 
 
 
PUT 
 
 
Замінаданих 	про заклад 	 	 
 	 	 
Admin 
 
 
/catering_establishment/{id}/ 
 
 
DELETE 
 
 
Видалення даних 	про заклад 	 	 
 	 	 
Продовження таблиці 1  
Роль,  що 
Ендпоінт 
HTTP- 
Призначення 	 	 
має доступ 
 
 
 
 
метод 
 
 
 	  	 	 
 	  	 	 
 
Registered 
/dish/ 
GET 
Повертає список  страв 
User, 
Admin 
 
 
 
 
 
 
 
у межах системи  	 
 	  	 	 
 	 	 	 
Registered 
/dish/{id}/ 
GET 
Повертає  страву 	із
User, 
Admin 
 
 
 
 
 
 
 
вказаним id  	 	 
 	  	 	 
 
Admin 
 
 
/dish/ 
 
 
POST 
 
 
Додавання нової страви до системи  	 	 
 	 	 	 
Admin 
 
 
/dish/{id}/ 
 
 
PUT 
 
 
Заміна 	даних  	про страву 	  	 	 
 	 	 
Admin 
 
 
/dish/{id}/ 
 
 
DELETE 
 
 
Видалення даних 	про страву 	  	 	 
 	 	 	 
Registered 
/ingredient/ 
GET 
Повертає   	список
User, 
 
 
інгредієнтів у 	межах
Admin 
 
 
 
 
 
системи 	  	 	 
 	 
Registered 
/ingredient/{id}/ 
GET 
Повертає 	інгредієнт  із
User, 
Admin 
 
 
 
 
 
 
 
вказаним id  	 	 
 	  	 	 
 	 	 
Admin 
 
 
/ingredient/ 
 
 
POST 
 
 
Додавання  нового інгредієнту до системи 
 	 	 	 
Admin 
 
 
/ingredient/{id}/ 
 
 
PUT 
 
 
Заміна 	даних  	про інгредієнт   	 	 
 	 	 
Admin 
 
 
/ingredient/{id}/ 
 
 
DELETE 
 
 
Видалення даних 	про інгредієнт   	 	 
 	 	 	 
Registered 
/user/ 
GET 
Повертає   	список
User, 
 
 
користувачів  у 	межах
Admin 
 
 
 
 
 
системи 	  	 	 
 	 	 	 	 
Продовження таблиці 1 
 
Роль,  що 
Ендпоінт 
HTTP- 
Призначення  	 
має доступ 
 
 
 
 
метод 
 
 
 	  	 	 
 	  	 	 
 	 	 
Registered 
/user/{id}/ 
GET 
Повертає  користувача
User, 
Admin 
 
 
 
 
 
 
 
із вказаним id  	 
 	  	 	 
 	 	 
Admin 
 
 
/user/ 
 
 
POST 
 
 
Додавання  	нового
користувача до системи 
 	 	 
Admin 
 
 
/user/{id}/ 
 
 
PUT 
 
 
пр
Заміна 	даних 	о користувача 	 	 
 	 	 
Admin 
 
 
/user/{id}/ 
 
 
DELETE 
 
 
  пр Видалення даних 	о користувача 	 	 
 	 	 	 
Registered 
/automatic_machine_type/ 
GET 
Повертає   	список
User, 
 
 
автоматів  у 	межах
Admin 
 
 
 
 
 
системи   	 	 
 	 	 	 
Registered 
/automatic_machine_type/{id}/ 
GET 
Повертає  автомат 	із
User, 
Admin 
 
 
 
 
 
 
 
вказаним id 	 	 
 	  	 	 
 	 	 
Admin 
 
 
/automatic_machine_type/ 
 
 
POST 
 
 
Додавання  нового автомату до системи 
 	 	 
Admin 
 
 
/automatic_machine_type/{id}/ 
 
 
PUT 
 
 
пр
Заміна 	даних 	о автомат 	  	 	 
 	 	 
Admin 
 
 
/automatic_machine_type/{id}/ 
 
 
DELETE 
 
 
  пр Видалення даних 	о автомат 	  	 	 
 
Registered 
/appropriate_dishes/ 
GET 
Повертає список  страв 
User, 
 
 
із інгредієнтів, id яких 
Admin 
  
 
 
   
 
 
   
 
 
та   кількість допустимих відсутніх інгредієнтів передані у параметрах запиту  
 	 	 	 	 
Продовження таблиці 1 
Роль,  що 
Ендпоінт 
HTTP- 
Призначення 	 
має доступ 
 
 
 
 
метод 
 
 
 	 	 
 	 	 
 	 
Registered 
/catering_establishments_with_ 
GET 
Повертає 	список
User, 
given_dishes/ 
 
закладів  громадського 
Admin 
 
 
 
  
 
 
  
 
 
харчування,   у яких можуть бути приготовані страви 
 
Registered 
/catering_establishment_ 
GET 
Повертає список страв, 
User, 
dish/{id}/ 
 
що 	можуть 	бути
Admin 
 
 
 
  
 
 
  
 
 
приготовані у вказаному закладі харчування  
 	 	 
   
3 Висновки 
 
     В ході даної лабораторної роботи було розроблено серверну частину програмної системи, створивши базу даних, організувавши взаємодію з нею веб- 
 
застосунку, забезпечивши перегляд, додавання, редагування та видалення інформації з неї, розробивши бізнес-логіку системи та надавши API для обробки HTTP-запитів до backend-частини відповідно до специфікації REST в рамках використання фреймворку Django REST Framework.

ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ  
1. Відеоролик  з  	демонстрацією  	роботи  	серверної  частини.  	URL  
https://youtu.be/j_4FfQ8NfBQ 
2. Посилання  на  	GitHub  	репозиторій  	з  	джерельним 
 кодом  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
ДОДАТОК А 
 
Реалізація пошуку страв, що складаються із вказаних інгредієнтів 
   
 
1 class AppropriateDishesWithIngredientsList( 
 
2 generics.ListCreateAPIView): 
 
3 """ 
 
4 Надання API для відображення страв, що можуть бути приготовані 
 
5 із вказаних інгредієнтів. 
 
6 """ 
 
7 serializer_class = serializers.AppropriateDishesSerializer 
 
8 
 
9 def get_queryset(self): 
 
10 """ 
11 Обробка GET-запиту на отримання списку страв. 
12 """ 
13 parameter_key = '0' 
14 query_parameters = self.request.query_params 
15 missed_count_parameter_list = \ 
16 list(query_parameters.getlist(parameter_key)) 
17 missed_count_parameter = \ 
18 int(query_parameters.getlist('1')[0]) \ 
19 if len(missed_count_parameter_list) >= 1 else 2 
20 parameter_set = \ 
21 set(map(int, list( 
22 query_parameters.getlist(parameter_key)))) 
	23 	 
24 return get_dishes_with_ingredients( 
25 parameter_set, missed_count_parameter) 
	26 	 
	27 	 
 
28 def get_dishes_with_ingredients( 
 
29 ingredients: set[int], 
 
30 acceptable_missed_count: int) -> dict[str: list[int]]: 
 
31 
 
32 
 
 
17 
33 """ 
 
34 Пошук страв, які можуть бути приготовані із інгредієнтів, що 
 
35 входять до списку ingredients. Допускається відсутність 
 
36 acceptable_missed_count інгредієнтів у страві. 
 
37 """ 
 
38 
 
39 dishes = [dish.id for dish in models.Dish.objects.all()] 
 
40 appropriate_dishes = list() 
 
41 almost_appropriate_dishes = list() 
 
42 
 
43 for dish_id in dishes: 
 
44 dish_ingredients = { 
45 item.ingredient_id for item in 
46 models.DishIngredient.objects.filter(dish=dish_id)} 
47 print(dish_ingredients) 
48 not_used_ingredients = \ 
49 dish_ingredients.difference(ingredients) 
50 not_used_ingredients_count = len(not_used_ingredients) 51 	if not_used_ingredients_count == 0: 
52 appropriate_dishes.append(dish_id) 
53 elif not_used_ingredients_count <= 54 	acceptable_missed_count: 
	55 	almost_appropriate_dishes.append(dish_id) 
	56 	 
 
57 return ( 
 
58 models.Dish.objects.filter( 
59 id__in=appropriate_dishes), 
60 models.Dish.objects.filter( 
61 id__in=almost_appropriate_dishes 
 
 













 
ДОДАТОК Б 
 
Реалізація пошуку закладів громадського харчування, у яких 
можуть приготувати вказані страви 
   
 
1 class DishSetCateringEstablishments( 
 
2 generics.ListAPIView): 
 
3 """ 
 
4 Надання API для відображення закладів громадського харчування, 
 
5 у яких можна замовити вказані страви. 
 
6 """ 
 
7 serializer_class = \ 
 
8 serializers.CateringEstablishmentSerializer 
	9 	 
 
10 def get_queryset(self): 
 
11 """ 
12 Обробка GET-запиту на отримання списку закладів. 
13 """ 
14 query_parameters = self.request.query_params 
	15 	 
16 dish_key = 'dish' 
17 wish_list = set(map(int, list( 
18 query_parameters.getlist(dish_key)))) 
	19 	 
20 automated_machines_with_given_dishes = \ 
21 models.AutomaticMachineDish.objects.filter( 
22 dish__in=wish_list) 
23 automated_machines_types_with_given_dishes = \ 
24 automated_machines_with_given_dishes. \ 
25 values_list('automatic_machine_type') 
26 dishes_cooked_by_machines = \ 
27 automated_machines_with_given_dishes.\ 
28 values_list('dish') 
	29 	 
30 machine_type_appropriate_dishes = \ 
31 get_list_mapped_to_integer( 

 
 
19 
  
32 automated_machines_types_with_given_dishes, 
33 dishes_cooked_by_machines) 
34 	 
35 catering_establishment_machines = \ 
36 get_catering_establishment_machines( 
37 automated_machines_types_with_given_dishes) 
38 	 
39 catering_establishments_that_cook_given_dishes = \ 
40 get_catering_establishments_that_cook_given_dishes( 
41 machine_type_appropriate_dishes, 
42 catering_establishment_machines, wish_list) 
43 	 
44 searched_catering_establishments = \ 
45 models.CateringEstablishment.objects.filter( 
46 id__in= 
47 catering_establishments_that_cook_given_dishes) 
48 searched_catering_establishments = \ 
49 choose_catering_establishment_by_location( 
50 query_parameters, 
51 searched_catering_establishments) 
52 	 
53 	return searched_catering_establishments 
54 	 
55 	 
 
56 def get_list_mapped_to_integer(keys, values): 
 
57 """ 
 
58 Складання словнику із масивів ключів і значень. 
 
59 """ 
 
60 result_dict = defaultdict(set) 
 
61 
 
62 for k in range(len(keys)): 
 
63 result_dict[keys[k][0]].add(values[k][0]) 
64 	 
 
return result_d 
 
 
2 
 

2 
 

2




2









